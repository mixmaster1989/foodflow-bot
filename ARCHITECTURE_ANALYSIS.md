# Анализ архитектуры FoodFlow Bot

## 1. Основные бизнес-цели проекта

1. **Автоматизация учета продуктов** — распознавание чеков через OCR, извлечение товаров и цен
2. **Управление виртуальным холодильником** — отслеживание наличия продуктов у пользователя
3. **Генерация рецептов на основе доступных ингредиентов** — AI-генерация рецептов
4. **Отслеживание КБЖУ** — автоматический учет калорий, белков, жиров, углеводов
5. **Режим покупок** — сканирование этикеток в магазине с последующим сопоставлением с чеком
6. **Сравнение цен** — OCR ценников, история цен, поиск актуальных цен через Perplexity AI
7. **Список покупок** — управление списком необходимых товаров

---

## 2. Текущая архитектура

**Тип:** Монолитное приложение (Telegram Bot)

**Структура:**
- **Монолит** — единое приложение на Python (aiogram 3.x)
- **Модульная организация:**
  - `handlers/` — обработчики команд и callback'ов (11 модулей)
  - `services/` — бизнес-логика (8 сервисов)
  - `database/` — ORM модели и миграции (SQLAlchemy 2.0)
- **API:** Только Telegram Bot API (входящие webhook/polling), внешние API:
  - OpenRouter API (для AI моделей)
  - Perplexity Sonar API (для веб-поиска)
- **База данных:** SQLite (по умолчанию) / PostgreSQL (через asyncpg)
- **Нет gRPC, REST API, Webhook endpoints** — только Telegram Bot API

**Паттерны:**
- Router-based routing (aiogram)
- FSM для состояний (shopping mode)
- Service layer для бизнес-логики
- Repository через SQLAlchemy ORM

---

## 3. Основные технические фичи

### Реализованные:

1. **OCR обработка чеков**
   - Мультимодальные модели (Gemini 2.0 Flash, Qwen2.5-VL, fallback цепочка)
   - Автоматическая нормализация через Perplexity Sonar
   - Сохранение брендов и количества

2. **Виртуальный холодильник**
   - Просмотр продуктов, категоризация
   - Управление количеством
   - История поступления

3. **AI-генерация рецептов**
   - OpenRouter API с fallback моделями
   - Кэширование рецептов (CachedRecipe)
   - Русскоязычные ответы

4. **Режим покупок (Shopping Mode)**
   - FSM для сессий покупок
   - OCR этикеток с извлечением КБЖУ
   - Fuzzy matching с позициями чека
   - UI для коррекции несопоставленных позиций

5. **Обработка ценников**
   - OCR ценников (название, цена, объем, магазин)
   - История цен с отслеживанием изменений
   - Поиск актуальных цен через Perplexity

6. **Коррекция продуктов**
   - Inline-кнопки для редактирования
   - Мгновенное сохранение изменений

7. **Статистика КБЖУ**
   - Дневная статистика потребления
   - Цели по КБЖУ (UserSettings)

8. **Список покупок**
   - Добавление/удаление товаров
   - Отметка купленных

### Запланированные (из SHOPPING_MODE_PLAN.md):

- Полная интеграция Shopping Mode с обработкой чека
- Геолокация для ценников
- Расширенная аналитика цен

---

## 4. Процесс тестирования и деплоя

### Тестирование:

- **Покрытие тестами:** Отсутствует (нет папки `tests/`, нет pytest конфигурации)
- **Тестовые скрипты:** Есть разовые скрипты (`test_all_models.py`, `test_perplexity_prices.py`, `test_web_search.py`) — не автоматизированные тесты
- **README упоминает:** `pytest tests/` — но папки нет

### Деплой:

- **PM2 (ecosystem.config.js):**
  - Автоперезапуск при падении
  - Ограничение памяти (200MB)
  - Логирование в stdout/stderr
- **CI/CD:** Отсутствует (нет `.github/workflows/`, нет GitLab CI)
- **Миграции:** Ручные через `migrations.py` (только для SQLite, проверка существования таблиц/колонок)
- **Конфигурация:** Через `.env` файл (Pydantic Settings)

**Проблемы:**
- Нет автоматических тестов
- Нет CI/CD pipeline
- Миграции только для SQLite (PostgreSQL требует ручных миграций)

---

## 5. Документация и постановка задач

### Документация:

- **README.md** — полная документация проекта (262 строки)
- **SECURITY_REPORT.md** — отчет о безопасности
- **SHOPPING_MODE_PLAN.md** — план реализации Shopping Mode (чеклист)
- **FoodFlow_Menu_Guidelines.txt** — гайдлайн по UX/UI меню (468 строк)
- **LICENSE** — MIT License

### Постановка задач:

- **Формат:** Markdown файлы с чеклистами (SHOPPING_MODE_PLAN.md)
- **Тикеты:** Не используются (нет интеграции с GitHub Issues/Jira)
- **Спеки:** Есть в виде Markdown (Menu Guidelines, Shopping Mode Plan)
- **TODO комментарии:** Минимальные (найдено 2 TODO в коде)

**Проблемы:**
- Нет системы тикетов
- Нет трекинга прогресса задач
- Документация разрозненная (не централизована)

---

## 6. Типовые проблемы

### Выявленные:

1. **Отсутствие тестов**
   - Нет unit/integration тестов
   - Нет покрытия кода
   - Риск регрессий при изменениях

2. **Техдолг:**
   - Миграции только для SQLite (нет версионирования для PostgreSQL)
   - Хардкод fallback моделей в коде (нет конфигурации)
   - TODO комментарии в коде (recipes.py, fridge.py)
   - "Hacky way to refresh" в fridge.py

3. **Хаотичное внедрение фич:**
   - Shopping Mode реализован частично (есть план, но не все пункты выполнены)
   - Множество тестовых скриптов в корне проекта
   - Дублирование структуры (есть `FoodFlow/` и корневая структура)

4. **Сложности внедрения новых разработчиков:**
   - Нет onboarding документации
   - Нет описания архитектурных решений
   - Смешанная структура (FoodFlow/ и корневая)

5. **Проблемы с зависимостями:**
   - Нет версионирования зависимостей (requirements.txt без версий для некоторых пакетов)
   - Нет lock файла (poetry.lock / Pipfile.lock)

---

## 7. Основные "боли" текущего стека

### Где теряется время:

1. **OCR обработка:**
   - Множественные fallback вызовы (до 5 моделей последовательно)
   - Нет кэширования результатов OCR
   - Синхронные вызовы внешних API (timeout 45s)

2. **База данных:**
   - SQLite по умолчанию (не масштабируется)
   - Миграции только для SQLite (ручные для PostgreSQL)
   - Нет индексов на часто используемых полях (user_id есть, но не везде)

3. **AI сервисы:**
   - Retry логика в коде (3 попытки с 0.5s задержкой)
   - Нет очереди запросов (может быть rate limit)
   - Нет кэширования рецептов на уровне сервиса (только в БД)

4. **Обработка фото:**
   - Загрузка через Bot API каждый раз (нет локального кэша)
   - Нет оптимизации изображений перед отправкой в OCR

5. **Логирование:**
   - Все логи в один файл (`foodflow.log`)
   - Нет ротации логов
   - Нет структурированного логирования (только текст)

### Где возникают баги:

1. **Fuzzy matching:**
   - Алгоритм сопоставления может давать ложные срабатывания
   - Нет валидации результатов matching

2. **FSM состояния:**
   - Состояния могут "зависать" при ошибках
   - Нет очистки состояний при таймаутах

3. **Обработка ошибок:**
   - Не все исключения обработаны (try/except не везде)
   - Нет централизованного error handler

4. **Нормализация данных:**
   - Зависимость от внешнего API (Perplexity)
   - Нет fallback при недоступности API

---

## 8. Зависимости между проектами/модулями

### Внутренние зависимости:

1. **handlers → services → database:**
   - Handlers вызывают сервисы
   - Сервисы используют database models
   - Четкое разделение слоев

2. **Сервисы между собой:**
   - `receipt.py` использует `OCRService`, `NormalizationService`, `MatchingService`
   - `shopping.py` использует `LabelOCRService`, `MatchingService`
   - `price_tag_ocr.py` использует `PriceSearchService`

3. **Обновление протоколов/структур данных:**
   - При изменении моделей БД нужно обновлять миграции
   - При изменении API ответов (OpenRouter, Perplexity) нужно обновлять парсинг
   - Частота: при добавлении новых фич (примерно раз в месяц по планам)

### Внешние зависимости:

1. **OpenRouter API:**
   - Модели могут меняться (deprecation)
   - Нужно обновлять список моделей в коде

2. **Perplexity API:**
   - Формат ответов может измениться
   - Rate limits не документированы

3. **Telegram Bot API:**
   - Стабильный, но обновления могут требовать изменений

**Проблемы:**
- Нет версионирования API контрактов
- Нет мониторинга изменений внешних API

---

## 9. Языки и фреймворки (основной стек)

### Backend:

- **Python 3.10+**
- **aiogram 3.0+** — Telegram Bot Framework
- **SQLAlchemy 2.0+** — ORM
- **asyncpg** — PostgreSQL async driver
- **aiosqlite** — SQLite async driver (неявно через DATABASE_URL)

### Вспомогательные библиотеки:

- **pydantic-settings** — конфигурация
- **aiohttp** — HTTP клиент
- **rapidfuzz** — fuzzy matching
- **requests** — синхронный HTTP (legacy?)

### Инфраструктура:

- **PM2** — процесс-менеджер (Node.js, но используется только для Python)
- **SQLite/PostgreSQL** — БД

### Внешние сервисы:

- **OpenRouter API** — агрегатор AI моделей
- **Perplexity Sonar API** — веб-поиск и нормализация
- **Telegram Bot API** — платформа бота

---

## 10. Сложности с масштабированием, архитектурой и legacy

### Масштабирование:

1. **SQLite ограничения:**
   - Не подходит для production с множеством пользователей
   - Нет конкурентного доступа
   - Нет репликации

2. **Монолитная архитектура:**
   - Невозможно масштабировать отдельные компоненты
   - Один процесс обрабатывает все запросы
   - Нет горизонтального масштабирования

3. **Внешние API:**
   - Rate limits не контролируются
   - Нет очереди запросов
   - Нет балансировки нагрузки

### Изменение архитектуры:

1. **Миграция на микросервисы:**
   - Требует рефакторинга всего кода
   - Нужен API Gateway
   - Нужна система очередей (RabbitMQ/Redis)

2. **Добавление REST API:**
   - Требует нового слоя (FastAPI/Flask)
   - Нужна аутентификация
   - Нужна документация API (OpenAPI)

3. **Разделение на модули:**
   - Уже есть разделение handlers/services/database
   - Но нет четких интерфейсов между модулями

### Поддержка legacy-кода:

1. **Дублирование структуры:**
   - Есть `FoodFlow/` и корневая структура
   - Неясно, какая актуальная

2. **Тестовые скрипты в корне:**
   - Засоряют структуру проекта
   - Не удалены после разработки

3. **Устаревшие подходы:**
   - Использование `requests` вместо `aiohttp` (если есть)
   - Синхронные вызовы в async контексте (если есть)

**Рекомендации:**
- Перейти на PostgreSQL для production
- Добавить Redis для кэширования
- Внедрить систему очередей для обработки OCR
- Разделить на сервисы: OCR Service, Recipe Service, Price Service

